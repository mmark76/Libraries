<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sharpen Your Tactics – Flashcards</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
    }
    h1 {
      text-align: center;
    }
    #topBar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      align-items: center;
      margin-bottom: 12px;
      font-size: 0.9em;
    }
    #card {
      text-align: center;
      border: 1px solid #ddd;
      padding: 12px;
      border-radius: 6px;
    }
    #boardImg {
      width: 400px;
      max-width: 100%;
      height: auto;
      border: 1px solid #ccc;
      margin-top: 8px;
    }
    .controls {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap;
    }
    button {
      padding: 6px 14px;
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid #777;
      background: #f4f4f4;
    }
    button:hover {
      background: #e8e8e8;
    }
    #solution {
      margin-top: 10px;
      font-weight: bold;
    }
    #meta, #stats, #difficulty, #motif, #side {
      margin-top: 6px;
      font-size: 0.9em;
      color: #333;
    }
    #favoriteIndicator {
      font-size: 1.2em;
      margin-left: 6px;
    }
    #favoriteIndicator.active {
      color: gold;
    }
  </style>
</head>
<body>
  <h1>Sharpen Your Tactics – Flashcards</h1>

  <div id="topBar">
    <label>
      Filter:
      <select id="filterSelect">
        <option value="all">All</option>
        <option value="white">White to move</option>
        <option value="black">Black to move</option>
        <option value="favorites">Favorites</option>
      </select>
    </label>

    <button id="btnRandom">Random</button>
    <button id="btnOrdered">Ordered</button>

    <button id="btnUploadImages">Load images</button>
    <button id="btnUploadJson">Load JSON</button>

    <button id="btnExport">Export JSON</button>
    <button id="btnAnalyze">Analyze with Stockfish</button>
  </div>

  <div id="card">
    <div id="meta"></div>
    <img id="boardImg" src="" alt="Position" />
    <div id="side"></div>
    <div id="difficulty"></div>
    <div id="motif"></div>
    <span id="favoriteIndicator">☆</span>

    <div class="controls">
      <button id="btnPrev">⟵ Previous</button>
      <button id="btnShow">Show solution</button>
      <button id="btnCorrect">I solved it</button>
      <button id="btnWrong">I missed it</button>
      <button id="btnFavorite">★ Favorite</button>
      <button id="btnNext">Next ⟶</button>
    </div>

    <div id="solution" style="display:none;"></div>
    <div id="stats"></div>
  </div>

  <!-- hidden inputs για upload από δίσκο -->
  <input type="file" id="imgFolderInput" webkitdirectory multiple style="display:none" />
  <input type="file" id="jsonInput" accept="application/json" style="display:none" />

  <script>
    let mode = "random";        // για ordered / random navigation
    let bookType = "default";   // "default" (Sharpen) ή "uploaded"

    function safePath(path) {
      return encodeURI(path);
    }

    // ---- DEFAULT ΒΙΒΛΙΟ: Sharpen Your Tactics (online images από /problems) ----
    const TOTAL = 1125;
    const cards = [];

    for (let i = 1; i <= TOTAL; i++) {
      cards.push({
        id: i,
        bookNumber: i,
        page: Math.floor((i - 1) / 12) + 1,
        image: `problems/problem_${i}.png`,
        sideToMove: i % 2 === 1 ? "White" : "Black",
        motif: [],
        difficulty: null,
        fen: null,
        ease: 2.5,
        interval: 1,
        due: Date.now(),
        correct: 0,
        wrong: 0,
        favorite: false,
        solution: null
      });
    }

    // ---- PROGRESS (μόνο για default Sharpen – όχι για uploaded books) ----
    const progressKey = "sharpen_flashcards_progress_v3";

    function loadProgress() {
      try { return JSON.parse(localStorage.getItem(progressKey)) || {}; }
      catch { return {}; }
    }

    function saveProgress(data) {
      localStorage.setItem(progressKey, JSON.stringify(data));
    }

    let progress = loadProgress();

    function restoreProgressToCards() {
      for (const card of cards) {
        const p = progress[card.id];
        if (p) {
          card.ease = p.ease ?? card.ease;
          card.interval = p.interval ?? card.interval;
          card.due = p.due ?? card.due;
          card.correct = p.correct ?? 0;
          card.wrong = p.wrong ?? 0;
          card.favorite = p.favorite ?? false;
        }
      }
    }
    restoreProgressToCards();

    function syncCardToProgress(card) {
      // για uploaded βιβλία δεν γράφουμε σε localStorage
      if (bookType !== "default") return;
      progress[card.id] = {
        ease: card.ease,
        interval: card.interval,
        due: card.due,
        correct: card.correct,
        wrong: card.wrong,
        favorite: card.favorite
      };
      saveProgress(progress);
    }

    function updateCardSRS(card, isCorrect) {
      if (isCorrect) {
        card.correct++;
        card.ease += 0.1;
        card.interval = Math.ceil(card.interval * card.ease);
      } else {
        card.wrong++;
        card.ease = Math.max(1.3, card.ease * 0.8);
        card.interval = 1;
      }
      card.due = Date.now() + card.interval * 24 * 60 * 60 * 1000;
      syncCardToProgress(card);
    }

    // ---- FILTERS ----
    function getFilteredIndices() {
      const filter = document.getElementById("filterSelect").value;
      const indices = [];
      for (let i = 0; i < cards.length; i++) {
        const c = cards[i];
        if (filter === "white" && c.sideToMove !== "White") continue;
        if (filter === "black" && c.sideToMove !== "Black") continue;
        if (filter === "favorites" && !c.favorite) continue;
        indices.push(i);
      }
      return indices;
    }

    function getNextDueCardIndex() {
      const now = Date.now();
      const filtered = getFilteredIndices();
      if (filtered.length === 0) return 0;

      const dueCards = filtered
        .map(idx => ({ idx, c: cards[idx] }))
        .filter(obj => obj.c.due <= now);

      if (dueCards.length > 0) {
        const pick = dueCards[Math.floor(Math.random() * dueCards.length)];
        return pick.idx;
      } else {
        const randomIdx = filtered[Math.floor(Math.random() * filtered.length)];
        return randomIdx;
      }
    }

    function getPrevIndex(currentIndex) {
      const filtered = getFilteredIndices();
      if (filtered.length === 0) return currentIndex;
      const pos = filtered.indexOf(currentIndex);
      if (pos === -1) return filtered[0];
      const newPos = (pos - 1 + filtered.length) % filtered.length;
      return filtered[newPos];
    }

    function getNextIndex(currentIndex) {
      const filtered = getFilteredIndices();
      if (filtered.length === 0) return currentIndex;
      const pos = filtered.indexOf(currentIndex);
      if (pos === -1) return filtered[0];
      const newPos = (pos + 1) % filtered.length;
      return filtered[newPos];
    }

    // ---- DISPLAY ----
    let currentIndex = getNextDueCardIndex();

    function showCard(index) {
      if (!cards.length) return;
      const card = cards[index];
      if (!card) return;

      const img = document.getElementById("boardImg");
      img.src = safePath(card.image);
      img.alt = "Problem " + card.bookNumber;

      document.getElementById("meta").textContent =
        "Problem " + card.bookNumber + " – page " + card.page;

      document.getElementById("side").textContent =
        card.sideToMove + " to move";

      document.getElementById("difficulty").textContent =
        "Difficulty: " + (card.difficulty || "-");

      document.getElementById("motif").textContent =
        "Motif: " + (card.motif && card.motif.length ? card.motif.join(", ") : "-");

      const favInd = document.getElementById("favoriteIndicator");
      favInd.classList.toggle("active", card.favorite);
      favInd.textContent = card.favorite ? "★" : "☆";

      document.getElementById("solution").style.display = "none";
      document.getElementById("solution").textContent = card.solution || "(no solution yet)";

      document.getElementById("stats").textContent =
        "Solved: " + card.correct +
        " | Missed: " + card.wrong +
        " | Ease: " + card.ease.toFixed(2) +
        " | Interval: " + card.interval + " days";
    }

    // ---- BUTTONS: SHOW / NEXT / PREV / CORRECT / WRONG / FAVORITE ----
    document.getElementById("btnShow").addEventListener("click", () => {
      document.getElementById("solution").style.display = "block";
    });

    document.getElementById("btnNext").addEventListener("click", () => {
      if (mode === "ordered") {
        currentIndex = getNextIndex(currentIndex);
      } else {
        currentIndex = getNextDueCardIndex();
      }
      showCard(currentIndex);
    });

    document.getElementById("btnPrev").addEventListener("click", () => {
      if (mode === "ordered") {
        currentIndex = getPrevIndex(currentIndex);
      } else {
        currentIndex = getNextDueCardIndex();
      }
      showCard(currentIndex);
    });

    document.getElementById("btnCorrect").addEventListener("click", () => {
      const card = cards[currentIndex];
      updateCardSRS(card, true);
      currentIndex = getNextDueCardIndex();
      showCard(currentIndex);
    });

    document.getElementById("btnWrong").addEventListener("click", () => {
      const card = cards[currentIndex];
      updateCardSRS(card, false);
      currentIndex = getNextDueCardIndex();
      showCard(currentIndex);
    });

    document.getElementById("btnFavorite").addEventListener("click", () => {
      const card = cards[currentIndex];
      card.favorite = !card.favorite;
      syncCardToProgress(card);
      showCard(currentIndex);
    });

    // ---- RANDOM & ORDERED MODES ----
    document.getElementById("btnRandom").addEventListener("click", () => {
      mode = "random";
      const filtered = getFilteredIndices();
      if (filtered.length === 0) return;
      currentIndex = filtered[Math.floor(Math.random() * filtered.length)];
      showCard(currentIndex);
    });

    document.getElementById("btnOrdered").addEventListener("click", () => {
      mode = "ordered";
      const filtered = getFilteredIndices();
      if (filtered.length === 0) return;
      currentIndex = filtered[0]; // ξεκινά από το 1ο (id=1) σύμφωνα με το φίλτρο
      showCard(currentIndex);
    });

    document.getElementById("filterSelect").addEventListener("change", () => {
      const filtered = getFilteredIndices();
      if (mode === "ordered") {
        currentIndex = filtered.length ? filtered[0] : 0;
      } else {
        currentIndex = getNextDueCardIndex();
      }
      showCard(currentIndex);
    });

    // ---- EXPORT JSON (Option B) ----
    document.getElementById("btnExport").addEventListener("click", () => {
      const exportData = cards.map(c => ({
        id: c.id,
        bookNumber: c.bookNumber,
        page: c.page,
        image: c.image,
        sideToMove: c.sideToMove,
        motif: c.motif,
        difficulty: c.difficulty,
        fen: c.fen,
        correct: c.correct,
        wrong: c.wrong,
        ease: c.ease,
        interval: c.interval,
        due: c.due,
        favorite: c.favorite,
        solution: c.solution
      }));

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "book_flashcards.json";
      a.click();
      URL.revokeObjectURL(url);
    });

    // ---- STOCKFISH HOOK (placeholder) ----
    document.getElementById("btnAnalyze").addEventListener("click", () => {
      const card = cards[currentIndex];
      if (!card.fen) {
        alert("Δεν υπάρχει ακόμη FEN για αυτό το πρόβλημα. Όταν το προσθέσουμε στο JSON, θα μπορεί να αναλυθεί με Stockfish.");
        return;
      }
      // μελλοντική ενσωμάτωση engine εδώ
    });

    // ---- UPLOAD IMAGES (LOCAL BOOK) ----
    const imgFolderInput = document.getElementById("imgFolderInput");
    const jsonInput = document.getElementById("jsonInput");

    document.getElementById("btnUploadImages").addEventListener("click", () => {
      imgFolderInput.click();
    });

    imgFolderInput.addEventListener("change", (e) => {
      const fileList = e.target.files;
      if (!fileList || !fileList.length) return;

      const files = Array.from(fileList).filter(f => f.type.startsWith("image/"));
      if (!files.length) {
        alert("Ο φάκελος δεν περιέχει εικόνες.");
        return;
      }

      files.sort((a, b) => {
        const ap = a.webkitRelativePath || a.name;
        const bp = b.webkitRelativePath || b.name;
        return ap.localeCompare(bp, undefined, { numeric: true });
      });

      // κάνουμε switch σε uploaded book
      bookType = "uploaded";

      // καθαρίζουμε το array, αλλά ΔΕΝ πειράζουμε το default progress στο localStorage
      cards.length = 0;

      for (let i = 0; i < files.length; i++) {
        const id = i + 1;
        const file = files[i];
        const url = URL.createObjectURL(file);
        cards.push({
          id: id,
          bookNumber: id,
          page: Math.floor(i / 12) + 1,
          image: url,
          sideToMove: id % 2 === 1 ? "White" : "Black",
          motif: [],
          difficulty: null,
          fen: null,
          ease: 2.5,
          interval: 1,
          due: Date.now(),
          correct: 0,
          wrong: 0,
          favorite: false,
          solution: null
        });
      }

      document.getElementById("filterSelect").value = "all";
      mode = "ordered";

      const filtered = getFilteredIndices();
      currentIndex = filtered.length ? filtered[0] : 0;
      showCard(currentIndex);

      alert("Φορτώθηκαν " + files.length + " τοπικές εικόνες ως νέο βιβλίο.");
    });

    // ---- IMPORT JSON ΓΙΑ ΤΟ ΤΡΕΧΟΝ ΒΙΒΛΙΟ (DEFAULT ή UPLOADED) ----
    document.getElementById("btnUploadJson").addEventListener("click", () => {
      jsonInput.click();
    });

    jsonInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      if (!cards.length) {
        alert("Δεν υπάρχουν κάρτες. Φόρτωσε πρώτα εικόνες (ή χρησιμοποίησε το default βιβλίο).");
        jsonInput.value = "";
        return;
      }

      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          if (!Array.isArray(data)) {
            alert("Το JSON πρέπει να είναι πίνακας (array) από αντικείμενα καρτών.");
            return;
          }
          let matched = 0;
          for (const obj of data) {
            if (typeof obj.id !== "number") continue;
            const card = cards.find(c => c.id === obj.id);
            if (!card) continue;

            if ("bookNumber" in obj) card.bookNumber = obj.bookNumber;
            if ("page" in obj) card.page = obj.page;
            if ("solution" in obj) card.solution = obj.solution;
            if ("difficulty" in obj) card.difficulty = obj.difficulty;
            if ("fen" in obj) card.fen = obj.fen;

            if ("motif" in obj) {
              if (Array.isArray(obj.motif)) card.motif = obj.motif;
              else if (typeof obj.motif === "string" && obj.motif.trim() !== "") {
                card.motif = [obj.motif.trim()];
              }
            }

            if ("correct" in obj) card.correct = obj.correct;
            if ("wrong" in obj) card.wrong = obj.wrong;
            if ("ease" in obj) card.ease = obj.ease;
            if ("interval" in obj) card.interval = obj.interval;
            if ("due" in obj) card.due = obj.due;
            if ("favorite" in obj) card.favorite = !!obj.favorite;

            syncCardToProgress(card);
            matched++;
          }
          showCard(currentIndex);
          alert("Το JSON εφαρμόστηκε σε " + matched + " κάρτες.");
        } catch (err) {
          alert("Σφάλμα κατά την ανάγνωση JSON: " + err.message);
        } finally {
          jsonInput.value = "";
        }
      };
      reader.readAsText(file, "utf-8");
    });

    // ---- INITIAL LOAD ----
    showCard(currentIndex);
  </script>
</body>
</html>
